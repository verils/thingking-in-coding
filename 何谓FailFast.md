# 何谓FailFast
我要说的FailFast，并不是Java List迭代器的FailFast。在这里我要吐槽一下，在中文词条里搜索时FailFast和FailSafe通常会成对出现。然而，FailFast
在迭代器里面是存在的，而FailSafe却并不代表任何具有实际意义的东西，因为严格来说多线程迭代器里并没有真正地“Fail”，那么又何来“Safe"呢？

我承认我对中文词条和某一些中文社区存在着偏见，毕竟抄袭成风、浮于表面和不思进取已经让我无法获取到任何有益的思想观点。FailFast这一词真正核心的释义
就是被极大程度地误导了。如果对于任何一个编程思想感兴趣，直接搜索英文词条会更有裨益，这是我唯一的建议。

## 什么是真正的FailFast
FailFast，旨在让程序的失败更快地暴露出来。我认为这是一个位于软件决策层面的非常棒的开发思想。

举个例子：你在解析一个JSON请求内容的时候，其中一个数据类型是错误的，它应该是数字`123`，而JSON当中是`"123"`。这个问题的出现可能是数据输入时前端
校验的缺失，也有可能是基于测试的目的人为录入的脏数据。总之，一个潜在的错误就这么产生了。但是这个数据并非核心数据，它是**可选的**，你这时其实就是
遇到了一个决策问题：是忽略错误，用默认值代替这个数字类型的属性，让程序通过呢？还是保证严格的数据审校规则，让程序中止并返回异常呢？

这两个决策有对应的称呼。前者让程序“假装正确”地通过叫做`Defensive Coding`；而将程序中断报错，则是我要说的`FailFast`

## FailFast的优势
FailFast是合理且非常有必要的。

有一些常见的开发观念：“我的程序不能出错啊，这样看起来太Low了”、“我写的代码一定是完美的，这样的错是不可饶恕的”、“怎么你这里又报错了，赶紧把代码完善
一下吧”。基于这些思想，致使开发人员在代码中留下了太多的`Defensive Code`，从而在后续的业务调整中出现了更隐蔽的业务bug时，却不知道从何查起，
或者至少也能花上半天来先定位错误来源（检查数据或者肉眼静态分析代码）。

而如果采用**FailFast优先**的决策来进行开发，那么你将在第一时间（数据入库之前）就知道错误的原因和位置。

Golang+Kubernetes做云原生应用开发是现下FailFast思想的最完美实践。Golang鼓励程序在错误中中断，所以它采用了一种基于error类型返回值的方式来
表明程序错误，而非常规的`try-catch`异常处理机制。更极端的是，如果对Go极快的启动速度和Kubernetes的调度机制加以利用，可以实现让服务在失败后快速
地Recover，所以说将应用设计为“可随时崩溃的”也不为过。

## FailFast的劣势
我不会一味地鼓吹一种开发思想的好处，也不建议强行套入公式般地使用它。FailFast当然是有坏处的，那就是它让你的程序变得对错误敏感，程序失败次数直线上升，
测试人员和产品经理对你的开发水平可能会产生质疑（误）

## 如何恰当地使用FailFast和Defensive Coding
每一种业务场景所采用的开发策略都是不可同一的，以下有集中常见的业务点：

- 核心业务：建议采用**FailFast优先**，在核心流程中尽早发现错误会大大减少所需要的后续工作（俗称“返工”），至少能在debug上减轻很多负担
- 边缘业务：建议采用**Defensive Coding**，如果业务不那么重要，那么减少它报错的次数是个恰当的做法，毕竟报错产生的阻塞跟用户体验是强相关的
- 可能潜在的脏数据：直接**FailFast**。如果99%的情况下都是正常数据，何必让剩下1%的脏数据在系统里苟延残喘呢？



