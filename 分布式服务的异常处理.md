# 分布式服务的异常处理
## 异常的类型
在微服务设计模式中，服务间互相调用而且调用出错是很常见的，错误通常有以下几种类型：

- 请求异常：调用方给出了不符合约定的信息，被调用方进行校验的时候不通过而返回
- 处理异常：被调用方由于代码本身的质量原因导致了异常，由被调用方的通用异常处理器捕获后返回
- IO异常：由于网络原因导致调用关系的双方通讯失败，由调用方的IO中断触发产生

对应到HTTP协议，Response StatusCode能满足对于不同情况下发生的错误描述：

- `4xx`：请求异常
- `5xx`：处理异常
- `0`：IO异常（根据不同HTTP Client Library的异常处理行为，这个情况会有出入，这里假设为`int`类型的默认值）

## 异常的表现（如何描述异常发生的原因）
异常的类型可以通过一协议约定的字段来描述，如上述HTTP Status Code，或者gRPC Status。但是，光有异常类型并不能完全说明异常发生的原因

在大部分的实践和开发经验中，开发者都会使用一个包装对象来同时满足正常和异常情况下的返回信息。例如：

```json
{
  "code": "业务异常的状态码，如400001。请绝对禁止返回与Status Code一致的错误码，否则这个字段毫无必要",
  "message": "用户可读的异常信息描述，一定要说人话",
  "data": "如果异常，返回null；如果非异常，这个字段是object或者list"
}
```

`code`和`message`都是用来描述异常信息的，差别在于`code`提供机器可识别的信息，而`message`的是提供人类可读的信息

不过，这是一个良好的实践，但它足够优雅吗？

不，我觉得这并不是一种很优雅的处理方式

## 如何优雅地响应和处理异常
### 假如没有异常发生
在这样的情况下，我们需要多余的`code`和`message`吗？不需要

对于任何REST API，它获取的是什么资源，就返回原始的资源类型，无需特意地使用包装

```
GET /projects

200 OK
[
  {
    "id": 1,
    "name": "my-project",
    "description": "This is my project"
  }
]
```

而在异常出现的时候，才需要返回`code`和`message`

```
GET /awrongpath

404 Not Found
{
  "timestamp": "2020-02-02T20:20:20+0800",
  "code": "Not Found",
  "message": "not found"
}
```

对于信息的处理，首先依据协议的Status来判断是正常还是异常返回，然后再走正常流程或异常处理逻辑

在这一小节里我只讨论习惯和规范性的内容，技术的实现不作为优先考虑。因为无论在何种情形，接口的规范和约定都优先于技术实现的难易程度。

### 异常信息如何翻译
不论是服务内部的业务处理（数据库操作，中间件操作，文件操作），还是对外部服务的调用（第三方服务，系统中的另一个微服务），产生的异常信息都不可能直接通过接口响应出去，因为微服务内部有自己的业务语义，而异常信息的语义跟异常的来源有着紧密的联系。

拿我最近做过的一个需求来说吧，一个管理多个Git系统的微服务（支持的Git系统有GitHub，GitLab和BitBucket），调用不同类型Git系统的接口，并处理响应回来的数据。

在这个场景中有三个参与者：业务系统，业务系统中的Git管理微服务，外部系统（Git服务）

在遇到异常的返回时，微务可以有两种处理异常的方式：

- 保留Git系统的原始异常信息，让下游服务去处理不同Git系统的异常语义
- 对Git系统的异常信息进行统一化处理，转换成业务系统的可识别的语义，再返回给下游服务

显而易见，作为业务系统和外部Git系统的桥梁，异常语义转换的行为，理应安排在这个Git管理的微服务上。直接的体现就是，这个服务生成一个业务异常，包含业务系统全局可识别的`code`，和一个描述性的`message`，通过层层调用链的返回最终达到用户的终端（浏览器页面中），如果有必要，下游服务还可以做进一步的处理和转义。但业务异常信息的源头，就是这个微服务。

### 异常信息的状态码该如何定义
我的推荐是，尽可能用语义化的字符串来表示。大部分的业务系统使用`int`类型的异常状态码，但是这样做有一个问题：状态码做不到自描述，管理人员看到状态码之后还要去查表才能理解其中的含义。

如何设计一个可以自描述的状态码呢？很简单，可以用一个固定的模板来定义：`service.business.details.detail1.detail2`

如，订单服务创建订单时参数校验错误，可以使用`code: "order.creation.validation.userid.null"`

这一模式参考自Tomcat的异常处理，Tomcat异常信息的国际化就是利用语义化key + `ResourceBundle`实现的（因为兴趣参与过Tomcat国际化翻译项目[POEditor - Tomcat](https://poeditor.com/projects/po_edit?id_language=31&id=221603)，进而翻看过Tomcat源码而了解到的）

## 总结
在异常处理的设计上，我的很多观点并不是强制的，每个人都有自己的经验和理由，我的想法也都是基于我自己的实践而总结的。只希望能给不太了解异常处理而迷茫的朋友一些解决思路，或者给经验丰富的人看到一种新鲜的玩法。如果任何新的想法，我会继续补充进来
